# let VS var

作用域：var 为函数级作用域，而 let 为块级作用域。

声明提升：var 声明的变量会自动提升至函数作用域顶部，JavaScript 引擎会注意到出现在块后部的let声明，但不允许在声明前引用变量，称为“暂时性死区”，抛出 ReferenceError。

重复声明：var允许重复声明，let 不允许重复声明并抛出 SyntaxError。已经用 var 声明了的变量不允许用 let 声明，反之亦然，抛出 SyntaxError，当然，在对应作用域中才会发生冲突。

全局声明：用 var 声明的全局变量会成为 window 对象的属性，但 let 声明的不会。

条件声明：不要试图在某种条件 ( if ) 下使用let声明变量，let声明的变量无法跳出条件控制的块级作用域。

# const

const 的行为与 let 基本一致，但 const 声明的变量必须在声明时初始化并且不允许改变变量的值，抛出 TypeError。

const 声明的变量被初始化为对象时，修改对象内部的属性是被允许的（只关心变量指向的地址是否被改变）。

# 数据类型

六种简单数据类型（原始类型）：Undefined, Null, Boolean, Number, String, Symbol（ES6）。

typeof：对一个值使用 typeof 时，返回以下字符串之一：

- "undefined" 变量未声明或被赋为 undefined
- "boolean" （布尔表达式的值并非一定返回布尔值）
- "string" 
- "number" 
- "object" 值是一个对象或null，且不是函数
- "function" 
- "symbol"

# Undefined 类型

Undefined 类型唯一的值就是 undefined，使用 var 或者 let 声明变量但未初始化时，变量被赋予 undefined 值。

虽然未被声明的变量无法访问，但可以对其使用 typeof 操作，返回undefined。


# Null 类型

Null 类型同样也只有一个值，即 null。

在定义将来要保存对象值的变量时，建议使用 null 来初始化。

# Boolean 类型

Boolean() 函数可以将一个非布尔值转换为布尔值，转换规则如下：

| 数据类型      | 转换为 true 的值 |  转换为 false 的值 |
| ----------- | ----------- |  ------- |
| Boolean  | true | false |
| String  | 非空字符串 |  “” （空字符串） |
| Number | 非零数值（包括无穷值） | 0、NaN |
| Object | 任意对象 | null |
| Undefined | N/A | undefined |

if 等控制流语句会自动执行其他类型值到布尔值的转换。

# Number 类型

Number 类型使用IEEE 754表示整数与浮点数。

以 0 开头的字面量数字会被当成八进制处理，但无效的八进制表示会被当做十进制数处理（数码大小超过了7， 079 当作 79 处理）。

八进制字面量在严格模式下是无效的，会导致语法错误，在 ES6 中应使用 0o 前缀。

十六进制字面量使用 0x 前缀， 其中的 x 区分大小写（似乎在非严格模式下并不区分），十六进制数字（A - F）不区分大小写。

## 浮点值

浮点值字面量必须包含小数点，且小数点后必须至少有个一个数字。小数点前的整数部分可以缺失，会被当做零处理。小数点后的小数部分如果缺失，字面量会被当做整数而非浮点数。

可以使用科学计数法定义字面量。默认情况下， ES 会将绝对值小于等于 1e-7 的值转化为科学计数法输出。

浮点数之间的运算存在浮点误差，因此 0.1 + 0.2 == 0.3 将得到 false。

## 值的范围

ES 可表示的最值保存在 Number.MIN_VALUE 和 Number.MAX_VALUE 中。其值在大多数浏览器中为 5e-324 和 1.7976931348623157e+308.

如果一个数超过了 ES 可表示的范围，则会被转换为一个特殊值，超过范围的正数转换为 Infinity，负数转换为 -Infinity。自然，typeof Infinity 得到 “number”。

判断一个数是否在表示范围内，可以使用 isFinite() 函数，对大于表示范围的数（Infinity）返回 false。

小于 Number.MIN_VALUE 的值将变成 0。

## NaN

0/0 得到 NaN。 5/0 得到 Infinity，0 的符号会影响 Infinity 的符号。

NaN 不等于包括 NaN 在内的任何值。任何涉及 NaN 的计算始终返回 NaN。

isNaN() 函数接收一个任意类型的参数，判断其是否为 NaN。例如，isNaN(NaN) 得到 true，isNaN("10") 得到 false，isNaN("xyz") 得到 true。事实上 Number("xyz") 返回的就是 NaN。

## 数值转换

Number(), parseInt(), parseFloat() 可以将非数值转换为数值。

Number() 函数基于如下规则执行

- 布尔值，true -> 1, false -> 0。
- 数值，直接返回。
- null，返回零。
- undefined, 返回NaN。
- 字符串，如果是有效的数值表示（允许正负号，忽略前导零的十进制数及前缀为 0x 的十六进制数，及允许科学计数法的有效浮点数表示。0o开头的有效八进制表示也是允许的，但书上没有给出）。开头和末尾的空格会被忽略。空字符串会被转换为 0。如果以上情况均不符合，返回NaN。
- 对象，先调用 valueOf() 方法，并按照上述方法处理返回值。如果结果是NaN，则调用 toString() 方法，按照字符串规则转换，最终返回。

parseInt() 函数会将字符串开头的空格全部忽略，从第一个非空格字符开始转换，如果第一个字符不是数值符号、加号或减号，直接返回 NaN，所以空字符串也将返回 NaN。如果第一个字符是数码、加号或减号，则会依次转换字符直到碰到非数码或字符串末尾。

parseInt() 也支持识别 0x 开头的十六进制数，但不支持 0o 开头的八进制数，碰到 o 会直接返回 0。

parseInt() 可以接受第二个参数用于指定进制，最大支持到 36 进制。如果指定为 16 进制则字符串开头的 0x 不会对结果有影响。否则，会因为无法解析 x 而返回 0。指定的进制大于 36 时，无论字符串是什么都返回 NaN。

parseFloat() 函数和 parseInt() 的区别在于允许数值中出现一次小数点。在没有小数点出现或小数点后只有 0 时返回整数值。

parseFloat() 函数只支持解析十进制数，故不接受第二个用于指定进制的参数。0x开头的字符串会返回零。

parseFloat() 允许省略整数部分及科学计数法。