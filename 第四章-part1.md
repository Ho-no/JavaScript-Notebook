# 原始值和引用值

上一章讨论了 6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。

引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。

在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript 打破了这个惯例。

## 动态属性

对于引用值，可以随时添加、修改和删除属性及方法。

原始值不能有属性，尽管尝试给原始值添加属性不会报错。比如：
    
    let name = "Nicholas"; 
    name.age = 27; 
    console.log(name.age); // undefined 

但可以使用包装类型来添加属性：
    
    let name = new String("Nicholas"); 
    name.age = 27; 
    console.log(name.age); // 27

## 复制值

将一个原始值赋值给另一个变量，会复制该值的值，而不是引用。但把引用值赋值给另一个变量，则会复制该引用，两个变量实际上指向同一个变量。（指针）

## 传递参数

ES 中所有函数的参数都是值传递的。以下这段代码可以反映其与引用传递的区别：

    function setName(obj) { 
        obj.name = "Nicholas"; 
        obj = new Object(); 
        obj.name = "Greg"; 
    } 
    let person = new Object(); 
    setName(person); 
    console.log(person.name); // "Nicholas" 

ES 中函数的参数都是局部变量。

## 确定类型

ES 中停供了 instanceof 操作符，用来确定一个值是否是某个类的实例。如果变量是给定引用类型（参见第 8 章）的实例，则 instanceof 操作符返回 true。

使用 instanceof 检测原始值始终返回 false，因为它们不是对象。

# 执行上下文与作用域

变量和函数的上下文决定了他们可以访问哪些数据，以及他们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量与函数都存在于这个对象中。

全局上下文是最外层的上下文。在浏览器中，全局上下文是 window 对象，因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。

上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数。

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。

上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。

代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。

## 作用域链增强

with 语句会向作用域链前端添加指定的对象。 catch 语局则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

## 变量声明

1. 使用 var 的函数作用域声明

    在使用 var 声明变量时，变量会被添加到最接近的上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文（即使是在函数内部）。

    var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”。

2. 使用 let 的块级作用域声明

    let 关键字跟 var 很相似，但它的作用域是块级的。

    let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。

    严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”的缘故，实际上不能在声明之前使用 let 变量。

3. 使用 const 的常量声明

    const 声明的变量必须同时初始化某个值，一经声明，在其生命周期的任何时候都不能再重新赋值。

    const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。

    如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败。

        const o3 = Object.freeze({}); 
        o3.name = 'Jake'; 
        console.log(o3.name); // undefined 

4. 标识符查找

    当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。

# 垃圾回收

## 标记清理

JavaScript 最常用的垃圾回收策略是标记清理。当变量进入上下文时，变量会被加上存在于上下文的标记。当变量离开上下文时，也会被加上离开上下文的标记。

垃圾回收程序运行时，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。

## 引用计数

另一种没那么常用的垃圾回收策略是引用计数。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。

引用技术策略无法解决循环引用问题。

## 内存管理

- 如果数据不再必要，那么把它设置为 null，从而释放其引用。
- const 和 let 以块为作用域，使用这两个关键字声明的变量可能会更早地让垃圾回收程序介入。
- 隐藏类：V8 会将共享同一个构造函数和原型的实例共享相同的隐藏类。
- 内存泄漏：意外声明全局变量；闭包。
  
